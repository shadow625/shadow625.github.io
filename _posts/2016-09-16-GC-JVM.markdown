---
layout:     post
title:      JVM-GC
date:       2016-09-16 21:35:18
summary:    JVM-GC
categories: java

---

#### JAVA垃圾回收算法

今天聊一下对于垃圾回收算法，掌握不是很全面，错了求指正[*附上邮箱*](wangpc625@gmail.com) 

 先来说一下常见的运行时数据区。如有疑问可以看一下[**JAVA docs:jvm-2.5 Runtime Dota Areas**](https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.5) 

 ![JRunTime](/image/JRunTime.png)

上图更清楚(*借用的图*)

我们以hotspot虚拟机为例

JAVA堆：用于分配JAVA对象和数组的空间，由所有JAVA虚拟机线程共享。随虚拟机启动，由于JAVA不需要显式的调用内存回收，所以GC需要在这里实现以保证虚拟机内存合理使用。

方法区：存储类元数据。

栈：线程栈，栈是跟随线程的，每一个JAVA方法调用会形成一个栈帧。

程序计数器：存储执行指令的内存地址。

堆 与方法区是所有线程共享的公共区域。堆与方法区所占的内存空间，是由JVM负责管理。

其中堆的内部因为分代回收机制被分为新生代与老年代（根据对象的声明周期对其进行分配不同的内存）



算法介绍：

主要阐述JAVA内存回收思想。

1. 最为基础的方法是标记清除：先将所有需要回收的内存标记，然后将其清除，使其变为可用内存，很容易知道这个算法的缺点：为被清除的对象还在原地址没有移动，所以导致回收后会产生不定大小的可用内存块（称做内存碎片，类似硬盘碎片），而这样对于以后的内存分配会有很大影响。还有一个周志明先生说的效率不高的问题，我的探索还不够深，不足以身切体会这个效率问题就暂时先记下来吧。
2. 复制回收：目前多数商用虚拟机会使用此方式回收新生代。在hotspot中新生代被分做三份，一个Eden区，两个survivor区（from区和to 区）比例为8：1：1（为啥，statistic。。。），每次内存分配只使用Eden区和一个survivor区， 回收时将这两个区的存活对象复制到另一个可用的survivor区，然后清空之前两个内存区，这样保证了垃圾回收后产生的内存区为连续可用的。
3. 标记整理算法：很容易理解，先将符合条件内存标记，然后将存活对象移动至一端，整理的意思就是将杂乱的已用内存分布整理为顺序的，这样的好处是回收过后产生的内存块都是连续的。

好了就说这些 只是大致的思想，实现方面正在看hotspot虚拟机实战，后期分享出来。

---

 大神路过的有意见的希望麻烦指正，感激不尽。